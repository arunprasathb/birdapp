<?php

namespace App\Providers;

use App\Helpers\AppUtility;
use App\Models\AccessToken;
use App\Models\User;

/**
 * UserServiceProvider class contains methods for user management
 */
class UserServiceProvider extends BaseServiceProvider {

    protected $userModelObj;
    protected $accessTokenObj;
    public function __construct()
    {
        $this->userModelObj = new User();
        $this->accessTokenObj = new AccessToken();
    }

    /**
     * Register a user
     * @param type $request
     * @return type
     */
    public function registerUser($request) {
        try {
            $utilObj = new AppUtility();
            $password = $utilObj->generatePassword($request['password']);
                $userId = $this->userModelObj->create($request,$password);
                $accessToken = md5(uniqid(mt_rand(), true));
                $isAccessTokenCreated = $this->accessTokenObj->create($request, $accessToken, $userId);
                if ($userId && $isAccessTokenCreated) {
                    UserServiceProvider::$data['status'] = 200;
                    UserServiceProvider::$data['data'] = array_merge($request->all(), ['accessToken' => $accessToken], ['id' => $userId]);
                    UserServiceProvider::$data['message'] = trans('messages.user_registered');
                    }
        } catch (\Exception $e) {
                $this->logError(__CLASS__,__METHOD__,$e->getMessage());
        }
        return UserServiceProvider::$data;
    }


    /**
     * Login User
     *
     * @param type $data
     * @return type
     */
    public function login($data) {
        try {
            UserServiceProvider::$data['message'] = trans('auth.failed');
            $user = User::where('email', $data['email'])->first();
            if(!empty($user)) {
                $utilObj = new AppUtility();
                $isPasswordMatched = $utilObj->matchPassword($data['password'], $user->password);
                if ($isPasswordMatched) {
                    $accessToken = md5(uniqid(mt_rand(), true));
                   $accessTokenData =  AccessToken::select('accessToken')->where('userId',$user->id)->where('deviceId',$data->deviceId)->where('deviceType',$data->deviceType)->first();
                    if(empty($accessTokenData)) {
                        $isAccessTokenCreated = $this->accessTokenObj->create($data, $accessToken, $user->id);
                        if ($user->id && $isAccessTokenCreated) {
                            UserServiceProvider::$data['status'] = 200;
                            UserServiceProvider::$data['data'] = array_merge(['accessToken' => $accessToken], ['id' => $user->id], ['name' => $user->name], ['email' => $user->email], ['status' => $user->status]);
                            // UserServiceProvider::$data['data'] = ['id' => $user->id];
                            UserServiceProvider::$data['message'] = trans('messages.login_success');
                        }
                    }else {
                        UserServiceProvider::$data['status'] = 200;
                        UserServiceProvider::$data['data'] = array_merge(['accessToken' => $accessTokenData->accessToken], ['id' => $user->id], ['name' => $user->name], ['email' => $user->email], ['status' => $user->status]);
                        UserServiceProvider::$data['message'] = trans('messages.already_login');
                    }
                }
            }

        } catch (\Exception $e) {
            $this->logError(__CLASS__,__METHOD__,$e->getMessage());
        }
        return UserServiceProvider::$data;
    }


    public function logout($data){
        try {
                    $isAccessTokenDeleted =  AccessToken::where('accessToken',$data->header('accessToken'))->delete();
                    if($isAccessTokenDeleted) {
                            UserServiceProvider::$data['status'] = 200;
                            UserServiceProvider::$data['message'] = trans('messages.logout_success');
 
                    }
 
        } catch (\Exception $e) {
            $this->logError(__CLASS__,__METHOD__,$e->getMessage());
        }
        return UserServiceProvider::$data;
    }



}